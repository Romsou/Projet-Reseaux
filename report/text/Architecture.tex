\section{L'architecture du code}
Il y a 4 grand types de paquets dans le projet:
\begin{itemize}
    \item Le paquet Client, qui contient un client classique pouvant se connecter aux serveurs.
    \item Le paquet Config, donnant la configuration de base(adresse ip et port) du serveur fédéré maître.
    \item Le paquet Serveur, qui contient le code des serveurs.
    \item Le paquet Tools, qui contient tout les outils utilisé par les serveurs et les clients pour communiquer.
\end{itemize}

Le fichier ServerLauncher.java lance seulement les serveurs chatAmuCentral présent dans pairs.cfg, alors que le fichier FederationLauncher.java lance le serveur maître et les serveurs esclaves conformément au contenu de config.cfg.

\subsection{Serveur}
Ce paquet contient tout les serveurs, que ce soit les serveurs de chat(ChatAmu), ou le serveur fédéré(Federation).

Tout les fichiers de ce paquet étendent la classe abstraite TemplateServer, qui correspond à la base d'un serveur, sauf la gestion des clés de connections, qui sont précisé par les sous classes, ChatAmuCentral.java et MasterServer.java.

\subsection{Tools}
Ce paquet contient tout les outils crées pour assurer la communication entre les serveurs et les clients.

Communication contient la classe IOCommunicator.java, qui est chargée de la lecture et de l'écriture dans les buffers des serveurs.

ConfigParser permet de récupérer les données du fichiers de config, afin de pouvoir connecter les serveurs au serveur maître.

Extended contient diverses classes étendue par délégation (conformément aux bonne pratiques objet.) et permet la gestion des erreurs du projet. L'idée était entre autre d'augmenter la lisibilité du code des serveurs en délocalisant la gestion des erreurs dans des classes et méthodes spécialisées.
Ce paquet contient également un enum contenant l'ensemble des codes erreurs du projet.

Protocol contient la classe ProtocolHandler.java, qui se charger de gérer ce qui a trait au protocole. Sa responsabilité est entre autre de reconnaître les headers, et de les manipuler.

UserManagment représente la base de clients connectés au serveur. Il contient les classes Register qui sert simplement de registre où sont enregistrés les clients au fur et à mesure de leurs connexions, et la classe ClientQueueManager qui contient les files de priorités des clients enregistrés

\section{Difficultés rencontrés}

Lors de l'élaboration de l'architecture du code, de nombreux problèmes ce sont posés, notamment de refactoring, dû aux nombreux éléments similaires entre les itérations successives des serveurs.
La gestion des erreurs en particulier fût relativement sportive dans la mesure où le nombre d'exceptions soulevés par les diverses classes du projet est assez nombreux.

